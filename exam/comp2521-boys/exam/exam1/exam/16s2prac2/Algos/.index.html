<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>Algorithms Almanac</title>
<link rel='stylesheet' type='text/css' href='../exam.css'></head>
<body>
<div align='center'>
<table width='100%' border='0'>
<tr valign='top'>
<td align='left' width='25%'>
  <span class='tiny'>COMP1927 14s2</span>
</td>
<td align='center' width='50%'>
  <span class='heading'>COMP1927 Sample Final Exam</span>
</td>
<td align='right' width='25%'>
  <span class='tiny'>Computing 2</span>
</td>
</table>
</div>
<center>
<h2>Algorithms Almanac</h2>
<p>
<b>Topic Index:</b>
&nbsp;
<span class="links">
<a href="#linear">Linear ADTs</a>
...
<a href="#sorting">Sorting</a>
...
<a href="#searching">Searching</a>
...
<a href="#graphs">Graphs</a>
</span>
</p>
</center>
<p>
This document gives code for representative ADTs and
algorithms discussed in COMP1927 14s2.
It's organised as a single long page, broken down by
topic area.
The code assumes that all collection types are made up of
<tt>Item</tt>s, where the <tt>Item</tt> type has equality,
less than, greater than, comparison, and display functions
available as <tt>eq(it1,it2)</tt>, <tt>less(it1,it2)</tt>,
<tt>greater(it1,it2)</tt>, <tt>cmp(it1,it2)</tt> and <tt>show(it)</tt>.
Sometimes, <tt>Item</tt>s have keys which are integer
or string values that uniquely identify the <tt>Item</tt>.
They key value can be extracted from an <tt>Item</tt>
using the <tt>key(it)</tt> function.
ADTs are implemented via a pointer to a hidden
representation type (e.g. the <tt>Stack</tt> type
is a pointer to a <tt>StackRep</tt> structure).
</p>
<p>
<b>Note:</b> the code below has not been compiled;
we make no guarantees that there are no bugs.
This code is provided simply as a guide to how
the algorithms were implemented.
</p>

<a name="linear"></a>
<h2>Linear ADTs
&nbsp;
<span class="links">(
<a href="#stacks">Stacks</a>
...
<a href="#queues">Queues</a>
...
<a href="#lists">Lists</a>
)</span>
</h2>

<a name="stacks"></a>
<h3>Stack ADT</h3>
<p>Interface:</p>
<pre>
typedef struct StackRep *Stack;
<span class="comment">// set up empty stack</span>
Stack newStack(int);
<span class="comment">// remove unwanted stack</span>
void dropStack(Stack);
<span class="comment">// insert an Item on top of stack</span>
void StackPush(Stack,Item);
<span class="comment">// remove Item from top of stack</span>
Item StackPop(Stack);
<span class="comment">// check whether stack is empty</span>
Bool StackIsEmpty(Stack);
</pre>
<p>Implementation (via arrays):</p>
<pre>
typedef struct StackRep {
   Item *item;
   int top;
} StackRep;
<span class="comment">// set up empty stack</span>
Stack newStack(int n)
{
   Stack s;
   s = malloc(sizeof(StackRep));
   assert(s != NULL);
   s-&gt;item = malloc(n * sizeof(Item));
   assert(s-&gt;item != NULL);
   s-&gt;top = -1;
   return s;
}
<span class="comment">// remove unwanted stack</span>
void dropStack(Stack s)
{
   assert(s != NULL);
   free(s-&gt;item);
   free(s);
}
<span class="comment">// insert Item on top of stack</span>
void StackPush(Stack s, Item it)
{
   assert(s-&gt;top &lt; MAXITEMS-1);
   s-&gt;top++;
   int i = s-&gt;top;
   s-&gt;item[i] = it;
}
<span class="comment">// remove Item from top of stack</span>
Item StackPop(Stack s)
{
   assert(s-&gt;top &gt; -1);
   int i = s-&gt;top;
   Item it = s-&gt;item[i];
   s-&gt;top--;
   return it;
}
<span class="comment">// check whether stack is empty</span>
Bool StackIsEmpty(Stack s)
{
   return (s-&gt;top &lt; 0);
}
</pre>

<a name="queues"></a>
<h3>Queue ADT</h3>
<p>Interface:</p>
<pre>
typedef struct QueueRep *Queue;
<span class="comment">// set up empty queue</span>
Queue newQueue(int);
<span class="comment">// remove unwanted queue</span>
void dropQueue(Queue);
<span class="comment">// insert Item at back of queue</span>
void QueueJoin(Queue,Item);
<span class="comment">// remove Item from front of queue</span>
Item QueueLeave(Queue);
<span class="comment">// check whether queue is empty</span>
Bool QueueIsEmpty(Queue);
</pre>
<p>Implementation (via arrays):</p>
<pre>
typedef struct QueueRep {
   Item *item;  <span class="comment">// array to hold Items</span>
   int front;  <span class="comment">// next Item to be removed</span>
   int back;  <span class="comment">// last Item added</span>
   int nitems;  <span class="comment">// # Items currently in queue</span>
   int maxitems;  <span class="comment">// size of array</span>
} QueueRep;
<span class="comment">// set up empty queue</span>
Queue newQueue(int n)
{
   Queue q;
   q = malloc(sizeof(QueueRep));
   assert(q != NULL);
   q-&gt;item = malloc(n * sizeof(Item));
   assert(q-&gt;item != NULL);
   q-&gt;front = q-&gt;back = 0;
   q-&gt;nitems = 0; q-&gt;maxitems = n;
   return q;
}
<span class="comment">// remove unwanted queue</span>
void dropQueue(Queue q)
{
   assert(q != NULL);
   free(q-&gt;item);
   free(q);
}
<span class="comment">// insert item on top of queue</span>
void QueueJoin(Queue q, Item it)
{
   assert(q-&gt;nitems &lt; q-&gt;maxitems);
   q-&gt;item[q-&gt;front] = it;
   q-&gt;nitems++;
   q-&gt;front = (q-&gt;front+1)%q-&gt;maxitems;
}
<span class="comment">// remove item from front of queue</span>
Item QueueLeave(Queue q)
{
   assert(q-&gt;nitems &gt; 0);
   Item it = q-&gt;item[q-&gt;back];
   q-&gt;nitems--;
   q-&gt;back = (q-&gt;back+1)%q-&gt;maxitems;
   return it;
}
<span class="comment">// check whether queue is empty</span>
Bool QueueIsEmpty(Queue q)
{
   return (q-&gt;nitems == 0);
}
</pre>

<a name="lists"></a>
<h3>List ADT</h3>
<p>Interface:</p>
<pre>
typedef struct ListRep *List;
<span class="comment">// create a new empty List</span>
List newList();
<span class="comment">// free up all space associated with list</span>
void freeList(List);
<span class="comment">// display list as one Item per line on stdout</span>
void showList(List);
<span class="comment">// apppend one Item to the end of a list</span>
void ListInsert(List, int);
<span class="comment">// delete first occurrence of v from a list</span>
<span class="comment">// if v does not occur in List, no effect</span>
void ListDelete(List, Item);
<span class="comment">// return number of elements in a list</span>
int ListLength(List);
</pre>
<p>Implementation (via linked list):</p>
<pre>
typedef struct ListNode {
   int  data;  <span class="comment">// value of this list item</span>
   struct ListNode *next;
               <span class="comment">// pointer to node containing next element</span>
} ListNode;
typedef struct ListRep {
   int  size;  <span class="comment">// number of elements in list</span>
   ListNode *first;  <span class="comment">// node containing first value</span>
   ListNode *last;  <span class="comment">// node containing last value</span>
} ListRep;
<span class="comment">// create a new empty List</span>
List newList()
{
   ListRep *L;
   L = malloc(sizeof(ListRep));
   assert (L != NULL);
   L-&gt;size = 0;
   L-&gt;first = NULL;
   L-&gt;last = NULL;
   return L;
}
<span class="comment">// free up all space associated with list</span>
void freeList(List L)
{
   ListNode *curr, *next;
   assert(L != NULL);
   curr = L-&gt;first;
   while (curr != NULL) {
      next = curr-&gt;next;
      free(curr);
      curr = next;
   }
   free(L);
}
<span class="comment">// display list as one integer per line on stdout</span>
void showList(List L)
{
   ListNode *curr;
   curr = L-&gt;first;
   while (curr != NULL) {
      show(curr-&gt;data); printf("\n");
      curr = curr-&gt;next;
   }
}
<span class="comment">// create a new ListNode with value it</span>
<span class="comment">// (this function is local to this ADT)</span>
static ListNode *newListNode(Item it)
{
   ListNode *n;
   n = malloc(sizeof(ListNode));
   assert(n != NULL);
   n-&gt;data = item;
   n-&gt;next = NULL;
   return n;
}
<span class="comment">// apppend one Item to the end of a list</span>
void ListInsert(List L, Item it)
{
   assert(L != NULL);
   ListNode *n;
   n = newListNode(it);
   if (L-&gt;first == NULL)
      L-&gt;first = L-&gt;last = n;
   else {
      L-&gt;last-&gt;next = n;
      L-&gt;last = n;
   }
   L-&gt;size++;
}
<span class="comment">// remove an item from a List</span>
void ListDelete(List L, Item it)
{
   assert(L != NULL);
   ListNode *curr, *prev;
   prev = NULL; curr = L-&gt;first;
   while (curr != NULL &amp;&amp; !eq(curr-&gt;data,it)) {
      prev = curr;
      curr = curr-&gt;next;
   }
   if (curr == NULL) return;
   if (prev == NULL)
      L-&gt;first = curr-&gt;next;
   else
      prev-&gt;next = curr-&gt;next;
   if (L-&gt;last == curr)
      L-&gt;last = prev;
   L-&gt;size--;
   free(curr);
}
<span class="comment">// return number of elements in a list</span>
int ListLength(List L)
{
   assert(L != NULL);
   return L-&gt;size;
}
</pre>

<p>Priority Queue:</p>
<p>Interface:</p>
<pre>
typedef struct PQueueRep *PQueue;
< span class="comment">create new empty priority queue</span>
PQueue newPQueue(int size);
<span class="comment">add item to priority queue</span>
void PQJoin(PQueue q, Item it);
<span class="comment">remove item from priority queue</span>
Item PQLeave(PQueue q);
<span class="comment">free up priority queue</span>
void dropPQueue(PQueue q);
</pre>
<p>Implementation:</p>
<pre>
struct PQueueRep {
    int   nItems; <span class="comment">// count of items</span>
    Item *items;  <span class="comment">// heap-array of Items</span>
    int   size;   <span class="comment">// size of array</span>
}
<span class="comment">// create a new empty queue</span>
PQueue newPQueue(int size)
{
    PQueue q = malloc(sizeof(struct PQrep));
    assert(q != NULL);
    <span class="comment">// indexes start from 1</span>
    q-&gt;items = malloc(sizeof(Item) * (size+1));
    assert(q-&gt;items != NULL);
    q-&gt;nItems = 0;
    q-&gt;size = size;
    return q;
}
<span class="comment">// add a new item into the queue</span>
void PQJoin(PQueue q, Item it)
{
    assert(q != NULL &amp;&amp; q-&gt;nItems &lt; q-&gt;size);
    q-&gt;nItems++;
    q-&gt;items[q-&gt;nItems] = it;
    fixUp(q-&gt;items, q-&gt;nItems);
}
<span class="comment">// remove item from priority queue</span>
Item PQLeave(PQueue q)
{
    assert(q != NULL &amp;&amp; q-&gt;nItems &gt; 0);
    swap(q-&gt;items, 1, q-&gt;nItems);
    q-&gt;nItems--;
    fixDown(p-&gt;items, 1, q-&gt;nItems);
    return q-&gt;items[q-&gt;nItems+1];
}
<span class="comment">free up priority queue</span>
void dropPQueue(PQueue q)
{
    assert(q != NULL);
    free(q-&gt;items);
    free(q);
}
void fixUp(Item a[], int k)
{
   while (k &gt; 1 &amp;&amp; less(a[k/2],a[k])) {
      swap(a, k, k/2);
      k = k/2;  <span class="comment">// integer division</span>
   }
}
void fixDown(Item a[], int k, int N)
{
    while (2*k &lt;= N) {
    int j = 2*k;
    <span class="comment">// choose larger of two children</span>
    if (j &lt; N &amp;&amp; less(a[j], a[j+1])) j++;
        if (!less(a[k], a[j])) break;
        swap(a, k, j);
        k = j;
    }
}
</pre>



<a name="sorting"></a>
<h2>Sorting
&nbsp;
<span class="links">(
<a href="#sort1">O(n<sup>2</sup>) Algs</a>
...
<a href="#sort2">O(n log n) Algs</a>
)</span>
</h2>

<a name="sort1"></a>
<h3>O(n<sup>2</sup>) Sorting Algorithms</h3>

<p>Sorting problem:</p>
<pre>
Pre-condition: a[0..N-1] contain Items
Post-condition: forall i:0..N-2,  key(a[i]) &leq; key(a[i+1])

Stability: consider item<sub>1</sub> and item<sub>2</sub> where key(item<sub>1</sub>) == key(item<sub>2</sub>)
if, before sorting, item<sub>1</sub> is a[i] &amp;&amp; item<sub>2</sub> is a[j] &amp;&amp; i &lt; j
then, after sorting, item<sub>1</sub> is a[m] &amp;&amp; item<sub>2</sub> is a[n] &amp;&amp; m &lt; n
</pre>

<p>Selection sort:</p>
<pre>
void selectionSort(int a[], int lo, int hi)
{
   int i, j, min;
   for (i = lo; i &lt; hi; i++) {
      min = i;
      for (j = i+1; j &lt;= hi; j++) {
         if (less(a[j],a[min])) min = j;
      }
      swap(a[i], a[min]);
   }
}
</pre>

<p>Bubble sort:</p>
<pre>
void bubbleSort(int a[], int lo, int hi)
{
   int i, j, nswaps;
   for (i = lo; i &lt; hi; i++) {
      nswaps = 0;
      for (j = hi; j &gt; i; j--) {
         if (less(a[j], a[j-1])) {
            swap(a[j], a[j-1]);
            nswaps++;
         }
      }
      if (nswaps == 0) break;
   }
}
</pre>

<p>Insertion sort:</p>
<pre>
void insertionSort(int a[], int lo, int hi)
{
   int i, j, val;
   for (i = lo+1; i <= hi; i++) {
      val = a[i];
      for (j = i; j &gt; lo; j--) {
         if (!less(val,a[j-1])) break;
         a[j] = a[j-1];
      }
      a[j] = val;
   }
}
</pre>

<a name="sort2"></a>
<h3>O(n log n) Sorting Algorithms</h3>

<p>Quicksort: <small>(with median-of-three partitioning)</small></p>
<pre>
void quicksort(Item a[], int lo, int hi)
{
   int i; <span class="comment">// index of pivot</span>
   if (hi &lt;= lo) return;
   medianOfThree(a, lo, hi);
   i = partition(a, lo+1, hi-1);
   quicksort(a, lo, i-1);
   quicksort(a, i+1, hi);
}
void medianOfThree(Item a[], int lo, int hi)
{
   int mid = (lo+hi)/2;
   if (less(a[mid],a[lo])) swap(a, lo, mid);
   if (less(a[hi],a[mid])) swap(a, mid, hi);
   if (less(a[mid],a[lo])) swap(a, lo, mid);
   <span class="comment">// now, we have a[lo] &leq; a[mid] &leq; a[hi]</span>
   <span class="comment">// swap a[mid] to a[lo+1] to use as pivot</span>
   swap(a, lo+1, mid);
}
int partition(Item a[], int lo, int hi)
{
   Item v = a[lo];  <span class="comment">// pivot</span>
   int  i = lo+1, j = hi;
   for (;;) {
      while (less(a[i],v) &amp;&amp; i &lt; j) i++;
      while (less(v,a[j]) &amp;&amp; j &gt; i) j--;
      if (i == j) break;
      swap(a,i,j);
   }
   j = less(a[i],v) ? i : i-1;
   swap(a,lo,j);
   return j;
}
</pre>

<p>Mergesort:</p>
<pre>
void mergesort(Item a[], int lo, int hi)
{
   int mid = (lo+hi)/2; <span class="comment">// mid point</span>
   if (hi &lt;= lo) return;
   mergesort(a, lo, mid);
   mergesort(a, mid+1, hi);
   merge(a, lo, mid, hi);
}
void merge(Item a[], int lo, int mid, int hi)
{
   int  i, j, k, nitems = hi-lo+1;
   Item *tmp = malloc(nitems*sizeof(Item));

   i = lo; j = mid+1; k = 0;
   <span class="comment">// scan both segments, copying to tmp</span>
   while (i &lt;= mid &amp;&amp; j &lt;= hi) {
     if (less(a[i],a[j]))
        tmp[k++] = a[i++];
     else
        tmp[k++] = a[j++];
   }
   <span class="comment">// copy items from unfinished segment</span>
   while (i &lt;= mid) tmp[k++] = a[i++];
   while (j &lt;= hi) tmp[k++] = a[j++];

   <span class="comment">//copy tmp back to main array</span>
   for (i = lo, k = 0; i &lt;= hi; i++, k++)
      a[i] = tmp[k];
   free(tmp);
}
</pre>

<p>Heapsort: <small>(require priority queue PQueue type)</small></p>
<pre>
void HeapSort(Item a[], int lo, int hi)
{
   PQueue pq = newPQueue(hi-lo+1);
   int i;
   for (i = lo; i &lt;= hi; i++) {
      PQJoin(pq, a[i]);
   }
   for (i = hi; i &gt;= lo; i--) {
      Item it = PQLeave(pq);
      a[i] = it;
   }
}
</pre>

<a name="searching"></a>
<h2>Searching
&nbsp;
<span class="links">(
<a href="#binsearch">Binary Search</a>
...
<a href="#bsts">BSTs</a>
...
<a href="#balanced">Balanced Trees</a>
...
<a href="#hashing">Hashing</a>
)</span>
</h2>

<a name="binsearch"></a>
<h3>Binary Search</h3>

<p>Binary search in array:</p>
<pre>
<span class="comment">// search for key k in array a[]
// - returns index of location for k
// - doesn't indicate whether key is actually there or not</span>
int findInArray(Key k, Item a[], int lo, int hi)
{
    if (hi &lt;= lo) return lo;
    int mid = (hi+lo)/2;
    int diff = cmp(k, key(a[mid]));
    if (diff &lt; 0)
        return findInArray(k, a, lo, mid);
    else if (diff &gt; 0)
        return findInArray(k, a, mid+1, hi);
    else
        return mid;
}
</pre>

<a name="bsts"></a>
<h3>Binary Search Trees (BSTs)</h3>
<p>BST Interface:</p>
<pre>
typedef struct Node *Tree;
<span class="comment">// create an empty Tree</span>
Tree newTree();
<span class="comment">// free memory associated with Tree</span>
void dropTree(Tree);
<span class="comment">// display a Tree (sideways)</span>
void showTree(Tree);
<span class="comment">// insert a new item into a Tree</span>
Tree TreeInsert(Tree, Item);
Tree TreeInsertAtRoot(Tree, Item);
Tree TreeInsertRandom(Tree, Item);
<span class="comment">// delete item with given key from Tree</span>
Tree TreeDelete(Tree, Key);
<span class="comment">// check whether item with given key is in Tree</span>
int TreeFind(Tree, Key);
<span class="comment">// compute depth of Tree</span>
int TreeDepth(Tree);
<span class="comment">// count #nodes in Tree</span>
int TreeNumNodes(Tree);
<span class="comment">// fetch i'th (from left) item from Tree</span>
Item *get_ith(Tree, int);
<span class="comment">// partition Tree around i'th Item</span>
Tree partition(Tree, int);
<span class="comment">// rotate Tree left/right around root</span>
Tree rotateR(Tree);
Tree rotateL(Tree);
</pre>
<p>BST Implementation:</p>
<pre>
typedef struct Node *Link;
typedef struct Node {
    Item value;
    Link left, right;
} Node;
<span class="comment">// make a new node containing an Item</span>
static Link newNode(Item it)
{
    Link new = malloc(sizeof(Node));
    assert(new != NULL);
    new-&gt;value = it;
    new-&gt;left = new-&gt;right = NULL;
    return new;
}
<span class="comment">// create a new empty Tree</span>
Tree newTree()
{
    return NULL;
}
<span class="comment">// free memory associated with Tree</span>
void dropTree(Tree t)
{
    if (t == NULL) return;
    dropTree(t-&gt;left);
    dropTree(t-&gt;right);
    free(t);
}
<span class="comment">// display a Tree (sideways)</span>
void showTree(Tree t)
{
    void doShowTree(Tree);
    doShowTree(t);
}
<span class="comment">// insert a new value into a Tree</span>
Tree TreeInsert(Tree t, Item it)
{
    if (t == NULL) return newNode(it);
    int diff = cmp(key(it),key(t-&gt;value));
    if (diff == 0)
        t-&gt;value = it;
    else if (diff &lt; 0)
        t-&gt;left = TreeInsert(t-&gt;left, it);
    else if (diff &gt; 0)
        t-&gt;right = TreeInsert(t-&gt;right, it);
    return t;
}
<span class="comment">// insert a new value as root of Tree</span>
Tree insertAtRoot(Tree t, Item it)
{ 
   if (t == NULL) return newNode(it);
   int diff = cmp(key(it), key(t-&gt;value));
   if (diff == 0)
      t-&gt;value = it;
   else if (diff &lt; 0) {
      t-&gt;left = insertAtRoot(t-&gt;left, it);
      printf("rotateR(%d)\n",t-&gt;value);
      t = rotateR(t);
   }
   else if (diff &gt; 0) {
      t-&gt;right = insertAtRoot(t-&gt;right, it);
      printf("rotateL(%d)\n",t-&gt;value);
      t = rotateL(t);
   }
   return t;
}
Tree insertRandom(Tree t, Item it)
{
   int size(Tree);

   if (t == NULL) return newNode(it);
   <span class="comment">// 1 in 3 chance of doing root insert</span>
   int chance = rand() % 3;
   if (chance == 0)
      t = insertAtRoot(t, it);
   else
      t = TreeInsert(t, it);
   return t;
}
<span class="comment">// delete item with given key from Tree</span>
Tree TreeDelete(Tree t, Key k)
{
    Tree deleteRoot(Tree);

    if (t == NULL)
        return NULL;
    int diff = cmp(k,key(t-&gt;value));
    if (diff == 0)
        t = deleteRoot(t);
    else if (diff &lt; 0)
        t-&gt;left = TreeDelete(t-&gt;left, k);
    else if (diff &gt; 0)
        t-&gt;right = TreeDelete(t-&gt;right, k);
    return t;
}
<span class="comment">// delete root of tree</span>
Tree deleteRoot(Tree t)
{
    Link newRoot;
    <span class="comment">// if no subtrees, tree empty after delete</span>
    if (t-&gt;left == NULL &amp;&amp; t-&gt;right == NULL) {
        free(t);
        return NULL;
    }
    <span class="comment">// if only right subtree, make it the new root</span>
    else if (t-&gt;left == NULL &amp;&amp; t-&gt;right != NULL) {
        newRoot = t-&gt;right;
        free(t);
        return newRoot;
    }
    <span class="comment">// if only left subtree, make it the new root</span>
    else if (t-&gt;left != NULL &amp;&amp; t-&gt;right == NULL) {
        newRoot = t-&gt;left;
        free(t);
        return newRoot;
    }
    <span class="comment">// else (t-&gt;left != NULL &amp;&amp; t-&gt;right != NULL)
    // so has two subtrees
    // - find inorder successor (grab value)
    // - delete inorder successor node
    // - move its value to root</span>
    Link parent = t;
    Link succ = t-&gt;right; // not null!
    while (succ-&gt;left != NULL) {
        parent = succ;
        succ = succ-&gt;left;
    }
    int succVal = succ-&gt;value;
    t = TreeDelete(t,succVal);
    t-&gt;value = succVal;
    return t;
}
<span class="comment">// check whether item with given key is in Tree</span>
int TreeFind(Tree t, Key k)
{
    if (t == NULL) return 0;
    int res, diff = cmp(k,key(t-&gt;value));
    if (diff &lt; 0)
        res = TreeFind(t-&gt;left, k);
    else if (diff &gt; 0)
        res = TreeFind(t-&gt;right, k);
    else <span class="comment">// (diff == 0)</span>
        res = 1;
    return res;
}
<span class="comment">// compute depth of Tree</span>
int TreeDepth(Tree t)
{
    if (t == NULL)
        return 0;
    else {
        int ldepth = TreeDepth(t-&gt;left);
        int rdepth = TreeDepth(t-&gt;right);
        //return 1 + (ldepth &gt; rdepth)?ldepth:rdepth;
        if (ldepth &gt; rdepth)
            return 1+ldepth;
        else
            return 1+rdepth;
    }
}
<span class="comment">// count #nodes in Tree</span>
int TreeNumNodes(Tree t)
{
    if (t == NULL) return 0;
    return 1 + TreeNumNodes(t-&gt;left)
             + TreeNumNodes(t-&gt;right);
}
<span class="comment">// fetch i'th (from left) item from Tree</span>
Item *get_ith(Tree t, int i)
{
   if (t == NULL) return NULL;
   assert(0 &lt;= i &amp;&amp; i &lt; size(t));
   int n = size(t-&gt;left); // #nodes to left of root
   if (i &lt; n) return get_ith(t-&gt;left, i);
   if (i &gt; n) return get_ith(t-&gt;right, i-n-1);
   return &(t-&gt;value);
}
<span class="comment">// // partition Tree around i'th Item</span>
Tree partition(Tree t, int i)
{
   if (t == NULL) return NULL;
   assert(0 &lt;= i &amp;&amp; i &lt; size(t));
   int n = size(t-&gt;left);
   if (i &lt; n) {
      t-&gt;left = partition(t-&gt;left, i);
      t = rotateR(t);
   }
   if (i &gt; n) {
      t-&gt;right = partition(t-&gt;right, i-n-1);
      t = rotateL(t);
   }
   return t;
}
<span class="comment">// rotate Tree right around node</span>
Link rotateR(Link n1)
{
   if (n1 == NULL) return n1;
   Link n2 = n1-&gt;left;
   if (n2 == NULL) return n1;
   n1-&gt;left = n2-&gt;right;
   n2-&gt;right = n1;
   return n2;
}
<span class="comment">// rotate Tree left around node</span>
Link rotateL(Link n2)
{
   if (n2 == NULL) return n2;
   Link n1 = n2-&gt;right;
   if (n1 == NULL) return n2;
   n2-&gt;right = n1-&gt;left;
   n1-&gt;left = n2;
   return n1;
}
</pre>
<p>Note that the above has operations relevant for balancing.<br>
The tree types below are specificaly designed to be balance.</p>

<a name="balanced"></a>
<h3>Balanced Trees</h3>
<p>Splay Trees:</p>
<pre>
#define L left
#define R right
<span class="comment">// Other operations are as for BSTs</span>
Tree insertSplay(Tree t, Item it)
{
   if (t == NULL) return newNode(it);
   int diff = cmp(key(it), key(t-&gt;value));
   if (diff == 0)
      t-&gt;value = it;
   else if (diff &lt; 0) {
      if (t-&gt;L == NULL) {
         t-&gt;L = newNode(it);
         t-&gt;nnodes++;
      }
      int ldiff = cmp(key(it), key(t-&gt;L-&gt;value));
      if (ldiff &lt; 0) {
         <span class="comment">// Case 1: left-child of left-child</span>
         t-&gt;L-&gt;L = insertSplay(t-&gt;L-&gt;L, it);
         t-&gt;L-&gt;nnodes++;
         t-&gt;nnodes++;
         t = rotateR(t);
      }
      else {
         <span class="comment">// Case 2: right-child of left-child</span>
         t-&gt;L-&gt;R = insertSplay(t-&gt;L-&gt;R, it);
         t-&gt;L-&gt;nnodes++;
         t-&gt;nnodes++;
         t-&gt;L = rotateL(t-&gt;L);
      }
      return rotateR(t);
   }
   else if (diff &gt; 0) {
      if (t-&gt;R == NULL) {
         t-&gt;R = newNode(it);
         t-&gt;nnodes++;
      }
      int rdiff = cmp(key(it), key(t-&gt;R-&gt;value));
      if (rdiff &lt; 0) {
         <span class="comment">// Case 3: left-child of right-child</span>
         t-&gt;R-&gt;L = insertSplay(t-&gt;R-&gt;L, it);
         t-&gt;R-&gt;nnodes++;
         t-&gt;nnodes++;
         t-&gt;R = rotateR(t-&gt;R);
      }
      else {
         <span class="comment">// Case 4: right-child of right-child</span>
         t-&gt;R-&gt;R = insertSplay(t-&gt;R-&gt;R, it);
         t-&gt;R-&gt;nnodes++;
         t-&gt;nnodes++;
         t = rotateL(t);
      }
      return rotateL(t);
   }
   else
      t-&gt;value = it;
   return t;
}
<span class="comment">// search Tree for item with key k</span>
Item *searchSplay(Tree *t, Key k)
{
   Link root = *t;
   if (root == NULL) return NULL;
   root = splay(root,k);
   *t = root;
   if (key(root-&gt;value) == k)
      return &amp;(root-&gt;value);
   else
      return NULL;
}
</pre>

<p>AVL Trees:</p>
<pre>
<span class="comment">// Other operations are as for BSTs</span>
Tree insertAVL(Tree t, Item it)
{
   if (t == NULL) return newNode(it);
   int diff = cmp(key(it), key(t-&gt;value));
   if (diff == 0)
      t-&gt;value = it;
   else if (diff &lt; 0) {
      t-&gt;left = insertAVL(t-&gt;left, it);
      t-&gt;nnodes = count(t);
   }
   else if (diff &gt; 0) {
      t-&gt;right = insertAVL(t-&gt;right, it);
      t-&gt;nnodes = count(t);
   }
   int dL = depth(t-&gt;left);
   int dR = depth(t-&gt;right);
   if ((dL - dR) &gt; 1) t = rotateR(t);
   else if ((dR - dL) &gt; 1) t = rotateL(t);
   return t;
}
</pre>

<p>2-3-4 Tree Interface:</p>
<pre>
typedef struct node *Tree;
<span class="comment">// Operations as for BST, except insert</span>
</pre>
<p>2-3-4 Tree Implementation:</p>
<pre>
typedef struct node {
   int  order;   <span class="comment">// 2, 3 or 4</span>
   Item data[3];  <span class="comment">// items in node</span>
   Tree child[4]; <span class="comment">// links to subtrees</span>
} Node;

<span class="comment">// create new 2-3-4 node</span>
static Node *newNode(Item it)
{
   Node *new = malloc(sizeof(Node));
   assert(new != NULL);
   new-&gt;order = 2;
   new-&gt;data[0] = it;
   new-&gt;child[0] = new-&gt;child[1] = NULL;
   return new;
}
<span class="comment">// search for item with key k</span>
Item *search(Tree t, Key k)
{
   if (t == NULL) return NULL;
   int i;  int diff;  int nitems = t-&gt;order-1;
   <span class="comment">// find relevant slot in items</span>
   for (i = 0; i &lt; nitems; i++) {
      diff = cmp(k, key(t-&gt;data[i]));
      if (diff <= 0) break;
   }
   if (diff == 0)
      <span class="comment">// match; return result</span>
      return &amp;(t-&gt;data[i]);
   else
      <span class="comment">// keep looking in relevant subtree</span>
      return search(t-&gt;child[i], k);
}
<span class="comment">//insert new Item into Tree</span>
Tree insert(Tree t, Item it)
{
   <span class="comment">// algorithm only ...</span>
   find leaf node where Item belongs (via search)
   if not full (i.e. order &lt; 4) {
      insert Item in this node, order++
   }
   else if node is full (i.e. contains 3 Items) {
      split into two 2-nodes as leaves
      promote middle element to parent
      insert item into appropriate leaf 2-node
      if parent is a 4-node {
         continue split/promote upwards
         if promote to root, and root is a 4-node {
            split root node
            add new root node
            promote middle item to new root
         }
      }
   }
}
</pre>

<p>Red-black Trees:</p>
<pre>
typedef enum {RED,BLACK} Colr;
typedef struct Node *Link;
typedef struct Node *Tree;
typedef struct Node {
   Item data;   <span class="comment">// actual data</span>
   Colr colour; <span class="comment">// colour of link to parent</span>
   Tree left;   <span class="comment">// left subtree</span>
   Tree right;  <span class="comment">// right subtree</span>
} Node;
<span class="comment">// make new node to hold supplied Item</span>
Node *newNode(Item it, Colr c)
{
   Node *new = malloc(sizeof(Node));
   assert(new != NULL);
   new-&gt;data = it; new-&gt;colour = c;
   new-&gt;left = new-&gt;right = NULL;
   return new;
}
<span class="comment">// search for Item with given key</span>
Item *search(Tree t, Key k)
{
   if (t == NULL) return NULL;
   int diff = cmp(k, key(t-&gt;data));
   if (diff &lt; 0)
      return search(t-&gt;left, k);
   else if (diffs &gt; 0)
      return search(t-&gt;right, k);
   else <span class="comment">// matches</span>
      return &amp;(t-&gt;data);
}
<span class="comment">// insert new Item into tree</span>
#define L left
#define R right
#define isRed(t) ((t) != NULL &amp;&amp; (t)-&gt;colour == RED)
void insert(Tree t, Item it)
{
   t-&gt;root = insertRB(t-&gt;root, it, 0);
   t-&gt;root-&gt;colour = RED;
}
Link insertRB(Link t, Item it, int inRight)
{
   if (t == NULL) return newNode(it,RED);
   <span class="comment">// node is a 4-node; lift it</span>
   if (isRed(t-&gt;L) &amp;&amp; isRed(t-&gt;R)) {
      t-&gt;colour = RED;
      t-&gt;L-&gt;colour = BLACK;
      t-&gt;R-&gt;colour = BLACK;
   }
   int diff = cmp(key(it),key(t-&gt;value));
   if (diff == 0)
      t-&gt;value = it;
   else if (diff &lt; 0) {
      t-&gt;L = insertRB(t-&gt;L, it, 0);
      if (isRed(t) &amp;&amp; isRed(t-&gt;L) &amp;&amp; inRight)
         t = rotateR(t);
      if (isRed(t-&gt;L) &amp;&amp; isRed(t-&gt;L-&gt;L)) {
         t = rotateR(t);
         t-&gt;colour = BLACK;
         t-&gt;R-&gt;colour = RED;
      }
   }
   else if (diff &gt; 0) {
      t-&gt;R = insertRB(t-&gt;R, it, 1);
      if (isRed(t) &amp;&amp; isRed(t-&gt;R) &amp;&amp; !inRight)
         t = rotateL(t);
      if (isRed(t-&gt;R) and isRed(t-&gt;R-&gt;R) {
         t = rotateL(t);
         t-&gt;colour = BLACK;
         t-&gt;L-&gt;colour = RED;
      }
   }
   return t;
}
<span class="comment">// other operations as for BSTs</span>
</pre>


<a name="hashing"></a>
<h3>Hashing</h3>

<p>Hash table Interface:</p>
<pre>
typedef struct HashTabRep *HashTable;
<span class="comment">// create an empty HashTable</span>
HashTable newHashTable(int);
<span class="comment">// free memory associated with HashTable</span>
void dropHashTable(HashTable);
<span class="comment">// insert a new value into a HashTable</span>
void hashTableInsert(HashTable, Item);
<span class="comment">// delete a value from a HashTable</span>
void hashTableDelete(HashTable, Key);
<span class="comment">// get Item from HashTable using Key</span>
Item *hashTableSearch(HashTable, Key);
</pre>
<p>Hash Table Implementation: <small>(separate chains)</small></p>
<pre>
#include "List.h"  <span class="comment">// use Lists of Items</span>
typedef struct HashTabRep {
   List *lists;  // lists of Items
   int   nslots; // # elements in array
   int   nitems; // # items stored in HashTable
} HashTabRep;
<span class="comment">// convert key to index</span>
static int hash(Key k, int N)
{
   int h = <span class="comment">... convert key to int</span>
   return h % N;
}
<span class="comment">// create an empty HashTable</span>
HashTable newHashTable(int N)
{
   HashTable new = malloc(sizeof(HashTable));
   assert(new != NULL);
   new-&gt;lists = malloc(N*sizeof(List));
   assert(new-&gt;items != NULL);
   int i;
   for (i = 0; i &lt; N; i++)
      new-&gt;lists[i] = newList();
   new-&gt;nslots = N;
   new-&gt;nitems = 0;
   return new;   
}
<span class="comment">// free memory associated with HashTable</span>
void dropHashTable(HashTable ht)
{
   free(ht-&gt;lists);
   free(ht);
}
<span class="comment">// insert a new value into a HashTable</span>
void hashTableInsert(HashTable ht, Item it)
{
   Key k = key(it);
   int i = hash(k, ht-&gt;nslots);
   ListInsert(ht-&gt;lists[i], it);
}
<span class="comment">// delete a value from a HashTable</span>
void hashTableDelete(HashTable ht, Key k)
{
   int i = hash(k, ht-&gt;nslots);
   ListDelete(ht-&gt;lists[i], k);
}
<span class="comment">// get Item from HashTable using Key</span>
Item *hashTableSearch(HashTable ht, Key k)
{
   int i = hash(k, ht-&gt;nslots);
   return ListSearch(ht-&gt;lists[i], k);
}
</pre>

</h2>
<p>Hash Table Implementation: <small>(linear probing)</small></p>
<pre>
#include "List.h"  <span class="comment">// use Lists of Items</span>
typedef struct HashTabRep {
   Item *items;  // lists of Items
   int   nslots; // # elements in array
   int   nitems; // # items stored in HashTable
} HashTabRep;
<span class="comment">// convert key to index</span>
static int hash(Key k, int N)
{
   int h = <span class="comment">... convert key to int</span>
   return h % N;
}
<span class="comment">// create an empty HashTable</span>
HashTable newHashTable(int N)
{
   HashTabRep *new = malloc(sizeof(HashTabRep));
   assert(new != NULL);
   new-&gt;items = malloc(N*sizeof(Item));
   assert(new-&gt;items != NULL);
   int i;
   for (i = 0; i &lt; N; i++)
      new-&gt;items[i] = NoItem;
   new-&gt;nslots = N; new-&gt;nitems = 0;
   return new;

}
<span class="comment">// free memory associated with HashTable</span>
void dropHashTable(HashTable ht)
{
   free(ht-&gt;items);
   free(ht);
}
<span class="comment">// insert a new value into a HashTable</span>
void hashTableInsert(HashTable ht, Item it)
{
   int N = ht-&gt;nslots;
   Item *data = ht-&gt;items;
   Key k = key(it);
   int ix, j, i = hash(k,N);
   for (j = 0; j &lt; N; j++) {
      ix = (i+j)%N;
      if (cmp(k,key(data[ix]) == 0)
         break;
      else if (data[ix] == NoItem)
         break;
   }
   if (j &lt; N) {
      data[ix] = it;
      ht-&gt;nitems++;
   }
}
<span class="comment">// delete a value from a HashTable</span>
void hashTableDelete(HashTable ht, Key k)
{
   int N = ht-&gt;nslots;
   Item *data = ht-&gt;items;
   int j, i = hash(k,N);
   for (j = 0; j &lt; N; j++) {
      int ix = (i+j)%N;
      if (cmp(k,key(data[ix]) == 0)
         break;
      else if (data[ix] == NoItem)
         return; <span class="comment">// k not in table</span>
   }
   data[ix] = NoItem;
   ht-&gt;nitems--;
   <span class="comment">// clean up probe path</span>
   j = ix+1;
   while (data[j] != NoItem) {
      Item it = data[j];
      data[j] = NoItem;
      ht-&gt;nitems--;
      insert(ht, it);
      j = (j+1)%N);
   }
}
<span class="comment">// get Item from HashTable using Key</span>
Item *hashTableSearch(HashTable ht, Key k)
{
   int N = ht-&gt;nslots;
   Item *data = ht-&gt;items;
   int j, i = hash(k,N);
   for (j = 0; j &lt; N; j++) {
      int ix = (i+j)%N;
      if (cmp(k,key(data[ix]) == 0)
         return &amp;(data[ix]);
   }
   return NULL;

}
</pre>

<a name="graphs"></a>
<h2>Graphs</h2>
&nbsp;
<span class="links">(
<a href="#graph-reps">Representation</a>
...
<a href="#traversal">Traversal</a>
...
<a href="#digraphs">Digraphs</a>
...
<a href="#wgraphs">Weighted Graphs</a>
)</span>
</h2>

<a name="graph-reps"></a>
<h3>Representation</h3>

<p>Graph Interface:</p>
<pre>
<span class="comment">// visible data structures for Graphs</span>
typedef struct GraphRep *Graph;
<span class="comment">// vertices denoted by integers 0..N-1</span>
typedef int Vertex;
<span class="comment">// edges are pairs of vertices (end-points)</span>
typedef struct { Vertex v; Vertex w; } Edge;
<span class="comment">// auxiliary operations on graphs</span>
int  validV(Graph,Vertex); <span class="comment">// validity check</span>
Edge mkEdge(Graph, Vertex, Vertex); <span class="comment">// edge creation</span>
int  neighbours(Graph, Vertex, Vertex); <span class="comment">// edge existence</span>
<span class="comment">// core operations on graphs</span>
<span class="comment">// make new graph with nV vertices</span>
Graph newGraph(int nV);
<span class="comment">// free memory allocated to graph</span>
void  dropGraph(Graph);
<span class="comment">// show "printable" representation of graph</span>
void  showGraph(Graph);
<span class="comment">// add new edge to a graph</span>
void  insertE(Graph, Edge);
<span class="comment">// remove an edge from a graph</span>
void  removeE(Graph, Edge);
<span class="comment">// returns #vertices & array of edges</span>
int   edges(Graph, Edge *, int);
</pre>
<p>Implementation of Auxiliary Operations:</p>
<pre>
<span class="comment">// is a vertex valid in a given Graph?</span>
static int validV(Graph g, Vertex v)
{
   return (g != NULL &amp;&amp; v &gt;= 0 &amp;&amp; v &lt; g-&gt;nV);
}
<span class="comment">// make an Edge value</span>
Edge mkEdge(Graph g, Vertex v, Vertex w)
{
   assert(validV(g,v) &amp;&amp; validV(g,w));
   Edge e = {v,w}; <span class="comment">// struct assignment</span>
   return e;
}
</pre>

<p>Adjacency Matrix Representation:</p>
<pre>
typedef struct GraphRep {
   int    nV;    <span class="comment">// #vertices</span>
   int    nE;    <span class="comment">// #edges</span>
   Bool **edges; <span class="comment">// matrix of booleans</span>
} GraphRep;
<span class="comment">// check whether two vertices are connected</span>
int neighbours(Graph g, Vertex v, Vertex w)
{
	assert(validV(g,v) &amp;&amp; validV(g,w));
	return g-&gt;edges[v][w];
}
<span class="comment">// make new graph with nV vertices</span>
Graph newGraph(int nV)
{
   assert(nV &gt;= 0);
   int i, j;
   int **e = malloc(nV * sizeof(int *));
   assert(e != NULL);
   for (i = 0; i &lt; nV; i++) {
      e[i] = malloc(nV * sizeof(int));
      assert(e[i] != NULL);
      for (j = 0; j &lt; nV; j++)
         e[i][j] = FALSE;
   }
   Graph g = malloc(sizeof(GraphRep));
   assert(g != NULL);
   g-&gt;nV = nV;  g-&gt;nE = 0;  g-&gt;edges = e;
   return g;
}
<span class="comment">// free memory allocated to graph</span>
void  dropGraph(Graph g)
{
   assert(g != NULL);
   int i;
   for (i = 0; i &lt; g-&gt;nV; i++)
      free(g-&gt;edges[i]);
   free(g-&gt;edges);
   free(g);
}
<span class="comment">// show "printable" representation of graph</span>
void  showGraph(Graph g)
{
   assert(g != NULL);
   printf("V=%d, E=%d\n", g-&gt;nV, g-&gt;nE);
   int i, j;
   for (i = 0; i &lt; g-&gt;nV; i++) {
      int nshown = 0;
      for (j = i+1; j &lt; g-&gt;nV; j++) {
         if (g-&gt;edges[i][j] != 0) {
            printf("%d-%d ",i,j);
            nshown++;
         }
      }
      if (nshown &gt; 0) printf("\n");
   }
}
<span class="comment">// add new edge to a graph</span>
void insertE(Graph g, Edge e)
{
   assert(g != NULL);
   assert(validV(g,e.v) &amp;&amp; validV(g,e.w));
   if (g-&gt;edges[e.v][e.w]) return;
   g-&gt;edges[e.v][e.w] = 1;
   g-&gt;edges[e.w][e.v] = 1;
   g-&gt;nE++;
}
<span class="comment">// remove an edge from a graph</span>
void removeE(Graph g, Edge e)
{
   assert(g != NULL);
   assert(validV(g,e.v) &amp;&amp; validV(g,e.w));
   if (!g-&gt;edges[e.v][e.w]) return;
   g-&gt;edges[e.v][e.w] = 0;
   g-&gt;edges[e.w][e.v] = 0;
   g-&gt;nE--;
}
<span class="comment">// returns #vertices &amp; array of edges</span>
int edges(Graph g, Edge *es, int nE)
{
   assert(g != NULL &amp;&amp; es != NULL);
   assert(nE &gt;= g-&gt;nE);
   int i, j, n = 0;
   for (i = 0; i &lt; g-&gt;nV; i++) {
      for (j = i+1; j &lt; g-&gt;nV; j++) {
         if (g-&gt;edges[i][j] != 0) {
            assert(n &lt; nE);
            es[n++] = mkEdge(g,i,j);
         }
      }
   }
   return n;
}
</pre>
<p>Adjacency List Representation:</p>
<pre>
typedef struct vNode *VList;
struct vNode { Vertex v; vList next; };
typedef struct graphRep GraphRep;
struct graphRep {
   int   nV;     <span class="comment">// #vertices</span>
   int   nE;     <span class="comment">// #edges</span>
   VList *edges; <span class="comment">// array of lists</span>
};
<span class="comment">// check whether two vertices are connected</span>
int neighbours(Graph g, Vertex v, Vertex w)
{
   assert(validV(g,v) &amp;&amp; validV(g,w));
   VList curr;
   curr = g-&gt;edges[v];
   while (curr != NULL) {
      if (curr-&gt;v == w) return 1;
   }
   return 0;
}
<span class="comment">// make new graph with nV vertices</span>
Graph newGraph(int nV)
{
   int i, j;
   VList *e = malloc(nV * sizeof(VList));
   assert(e != NULL);
   for (i = 0; i &lt; nV; i++) e[i] = NULL;
   Graph g = malloc(sizeof(GraphRep));
   assert(g != NULL);
   g-&gt;nV = nV;  g-&gt;nE = 0;  g-&gt;edges = e;
   return g;
}
<span class="comment">// free memory allocated to graph</span>
void  dropGraph(Graph g)
{
   assert(g != NULL);
   int i;
   for (i = 0; i &lt; g-&gt;nV; i++)
      freeVList(g-&gt;edges[i]);
   free(g);
}
<span class="comment">// show "printable" representation of graph</span>
void  showGraph(Graph)
{
   assert(g != NULL);
   printf("V=%d, E=%d\n", g-&gt;nV, g-&gt;nE);
   int i;
   for (i = 0; i &lt; g-&gt;nV; i++) {
      vNode *n = g-&gt;edges[i];
      while (n != NULL) {
         printf("%d-%d ",i,n-&gt;v);
         n = n-&gt;next;
      }
      if (g-&gt;edges[i] != NULL) printf("\n");
   }
}
<span class="comment">// add new edge to a graph</span>
void  insertE(Graph g, Edge e)
{
   assert(g != NULL);
   assert(validV(g,e.v) &amp;&amp; validV(g,e.w));
   int orig = length(g-&gt;edges[e.v]);
   g-&gt;edges[e.v] = insertVList(g-&gt;edges[e.v], e.w);
   g-&gt;edges[e.w] = insertVList(g-&gt;edges[e.w], e.v);
   if (length(g-&gt;edges[e.v]) &gt; orig) g-&gt;nE++;
}
<span class="comment">// remove an edge from a graph</span>
void  removeE(Graph g, Edge e)
{
   assert(g != NULL);
   assert(validV(g,e.v) &amp;&amp; validV(g,e.w));
   int orig = length(g-&gt;edges[e.v]);
   g-&gt;edges[e.v] = deleteVList(g-&gt;edges[e.v], e.w);
   g-&gt;edges[e.w] = deleteVList(g-&gt;edges[e.w], e.v);
   if (length(g-&gt;edges[e.v]) &lt; orig) g-&gt;nE--;
}
<span class="comment">// returns #vertices &amp; array of edges</span>
int edges(Graph g, Edge *es, int nE)
{
   VList curr;
   assert(g != NULL &amp;&amp; es != NULL);
   assert(nE &gt;= g-&gt;nE);
   int w, n = 0;
   for (w = 0; w &lt; g-&gt;nV; w++) {
      curr = g-&gt;edges[w];
      while (curr != NULL) {
         if (w &lt; curr-&gt;v)
            es[n++] = mkEdge(g,w,curr-&gt;v);
         curr = curr-&gt;next;
      }
   }
   return n;
}
</pre>

<a name="traversal"></a>
<h3>Traversal</h3>

<p>Path Checking:</p>
<pre>
int *visited;  <span class="comment">// array of booleans</span>
               <span class="comment">// indexed by vertex 0..V-1</span>

<span class="comment">// DFS : depth-first search</span>
int hasPath(Graph g, Vertex src, Vertex dest)
{
   int i;
   visited = malloc(g-&gt;nV*sizeof(int));
   for (i = 0; i &lt; g-&gt;nV; i++) visited[i] = 0;
   return dfsPathCheck(g, src, dest);
}
int dfsPathCheck(Graph g, Vertex v, Vertex dest)
{
   visited[v] = 1;
   Vertex w;
   for (w = 0; w &lt; g-&gt;nV; w++) {
      if (g-&gt;edges[v][w] &amp;&amp; w == dest)
         return 1; <span class="comment">// found path</span>
      if (g-&gt;edges[v][w] &amp;&amp; !visited[w])
         return dfsPathCheck(g, w);
   }
   return 0; <span class="comment">// no path from src to dest</span>
}

<span class="comment">// BFS : breadth-first search</span>
int hasPath(Graph g, Vertex src, Vertex dest)
{
   int *visited = calloc(g-&gt;nV,sizeof(int));
   Queue q = newQueue();
   QueueJoin(q,src);
   int isFound = 0;
   while (!QueueIsEmpty(q) &amp;&amp; !isFound) {
      Vertex y, x = QueueLeave(q);
      if (visited[x]) continue;
      for (y = 0; y &lt; g-&gt;nV; y++) {
         if (!g-&gt;edges[x][y]) continue;
         if (y == dest) { isFound = 1; break; }
         if (!visited[y]) { QueueJoin(q,y); }
      }
   }
   free(visited);
   return isFound;
}
</pre>

<p>Find and Display Shortest Path:</p>
<pre>
int findPath(Graph g, Vertex src, Vertex dest)
{
   int i;
   <span class="comment">// array of "been visited" flags</span>
   int *visited = malloc(g-&gt;nV * sizeof(int));
   for (i = 0; i &lt; g-&gt;nV; i++) visited[i] = 0;
   <span class="comment">// array of path predecessor vertices</span>
   Vertex *path = malloc(g-&gt;nV * sizeof(Vertex));
   Queue q = newQueue();
   QueueJoin(q, src); visited[src] = 1;
   int isFound = 0;
   while (!emptyQ(q) &amp;&amp; !isFound) {
      Vertex y, x = QueueLeave(q);
      for (y = 0; y &lt; g-&gt;nV; y++) {
         if (!g-&gt;edges[x][y]) continue;
         path[y] = x;
         if (y == dest) { isFound = 1; break; }
         if (!visited[y]) {
            QueueJoin(q, y);
            visited[y] = 1;
         }
      }
   }
   if (isFound) {
      <span class="comment">// display path in dest..src order</span>
      Vertex v;
      for (v = dest; v != src; v = path[v])
          printf("%d&lt;-", v);
      printf("%d\n", src);
   }
}
</pre>

<p>Connected Components:</p>
<pre>
int *componentOf;  <span class="comment">// array of component ids</span>
                   <span class="comment">// indexed by vertex 0..V-1</span>
int ncounted;      <span class="comment">// # vertices included so far</span>

void components(Graph g)
{
   void dfsComponents(Graph,Vertex,int);
   int i, comp = 0;
   componentOf = malloc(g-&gt;nV*sizeof(int));
   for (i = 0; i &lt; g-&gt;nV; i++) componentOf[i] = -1;
   ncounted = 0;
   while (ncounted &lt; g-&gt;nV) {
      Vertex v;
      for (v = 0; v &lt; g-&gt;nV; v++)
         if (componentOf[v] == -1) break;
      dfsComponents(g, v, comp);
      comp++;
   }
   <span class="comment">// componentOf[] is now set</span>
}
void dfsComponents(Graph g, Vertex v, int c)
{
   componentOf[v] = c;
   ncounted++;
   Vertex w;
   for (w = 0; w &lt; g-&gt;nV; w++) {
      if (g-&gt;edges[v][w] &amp;&amp; componentOf[w] == -1)
         dfsComponents(g, w, c);
   }
}
</pre>

<p>Hamilton Path Check:</p>
<pre>
int *visited; <span class="comment">// array of nV bools</span>
int HamiltonR(Graph g, Vertex v, Vertex w, int d)
{
   int t;
   if (v == w) return (d == 0) ? 1 : 0;
   visited[v] = 1;
   for (t = 0; t &lt; g-&gt;nV; t++) {
      if (!neighbours(g,v,t)) continue;
      if (visited[v] == 1) continue;
      if (HamiltonR(g,t,w,d-1)) return 1;
   }
   visited[v] = 0;
   return 0;
}
int hasHamiltonPath(Graph g, Vertex src, Vertex dest)
{
   visited = calloc(g-&gt;nV,sizeof(int));
   int res = HamiltonR(g, src, dest, g-&gt;nV-1);
   free(visited);
   return res;
}
</pre>

<a name="digraphs"></a>
<h3>Digraphs</h3>

<p>Digraph Interface/Representation:</p>
<pre>
<span class="comment">// Same interface as for simple graphs
// Representation changes:
// - essentially the same data structures
// - if using adjacency matrix, no longer symmetric
// - if using adjacency lists, no longer store (v,w) and (w,v)</span>
</pre>

<p>Web Crawler:</p>
<pre>
<span class="comment">// abstract algorithm only</span>
webCrawler(startingURL)
{
   mark startingURL as alreadySeen
   enqueue(Q, startingURL)
   while not empty(Q) {
      nextPage = dequeue(Q)
      <em>visit</em> nextPage
      foreach (hyperLink in nextPage) {
         if (hyperLink not alreadySeen) {
            mark hyperLink as alreadySeen
            enqueue(Q, hyperLink)
         }
      }
   }
}
</pre>

<p>Reachability, Transitive Closure:</p>
<pre>
int **tc; <span class="comment">// VxV matrix indicating reachability</span>

<span class="comment">// build an empty VxV matrix</span>
int **makeMatrix(int nrows, int ncols, int init)
{
   int i, j;
   int **m = malloc(nrows * sizeof(int *));
   assert(m != NULL);
   for (i = 0; i &lt; nrows; i++) {
      m[i] = malloc(ncols*sizeof(int));
      assert(m[i] != NULL);
      for (j = 0; j &lt; ncols; j++) m[i][j] = init;
   }
   return m;
}
<span class="comment">// build transitive closure matrix</span>
void makeClosure(Graph g)
{
   int i, s, t, V = g-&gt;nV;
   tc = makeMatrix(V, V, 0);
   for (s = 0; s &lt; V; s++) {
      for (t = 0; t &lt; V; t++)
         tc[s][t] = g-&gt;edges[s][t];
   }
   for (i = 0; i &lt; V; i++) {
      for (s = 0; s &lt; V; s++) {
         if (tc[s][i] == 0) continue;
         for (t = 0; t &lt; V; t++)
            if (tc[i][t] == 1) tc[s][t] = 1;
      }
   }
   g-&gt;tc = tc;
}
<span class="comment">// is there some path from src to dest</span>
int reachable(Graph g, Vertex src, Vertex dest)
{
    if (g-&gt;tc == NULL) makeClosure(g);
    return g-&gt;tc[src][dest];
}
</pre>

<a name="wgraphs"></a>
<h3>Weighted Graphs</h3>

<p>Graph Interface:</p>
<pre>
<span class="comment">// visible data structures for Graphs</span>
typedef struct GraphRep *Graph;
<span class="comment">// vertices denoted by integers 0..N-1</span>
typedef int Vertex;
<span class="comment">// edges are end-points + weight</span>
typedef struct { Vertex src; Vertex dest; float weight; } Edge;
<span class="comment">// auxiliary operations on graphs</span>
int validV(Graph,Vertex); <span class="comment">// validity check</span>
Edge mkEdge(Graph, Vertex, Vertex, float); <span class="comment">// edge creation</span>
int neighbours(Graph, Vertex, Vertex); <span class="comment">// edge existence</span>
float compareE(Edge e1, Edge e2); <span class="comment">// compare edge weights</span>
<span class="comment">// core operations on graphs</span>
<span class="comment">// make new graph with nV vertices</span>
Graph newGraph(int nV);
<span class="comment">// free memory allocated to graph</span>
void  dropGraph(Graph);
<span class="comment">// show "printable" representation of graph</span>
void  showGraph(Graph);
<span class="comment">// add new edge to a graph</span>
void  insertE(Graph, Edge);
<span class="comment">// remove an edge from a graph</span>
void  removeE(Graph, Edge);
<span class="comment">// returns #vertices & array of edges</span>
int   edges(Graph, Edge *, int);
</pre>
<p>Implementation of Auxiliary Operations:</p>
<pre>
<span class="comment">// is a vertex valid in a given Graph?</span>
static int validV(Graph g, Vertex v)
{
   return (g != NULL &amp;&amp; v &gt;= 0 &amp;&amp; v &lt; g-&gt;nV);
}
<span class="comment">// make an Edge value</span>
Edge mkEdge(Graph g, Vertex v, Vertex w)
{
   assert(validV(g,v) &amp;&amp; validV(g,w));
   Edge new;
   new.src = src;
   new.dest = dest;
   new.weight = weight;
   return new;
}
<span class="comment">// compare Edge weights</span>
int compareE(Edge e1, Edge e2)
{
   return e1.weight - e2.weight;
}
</pre>

<p>Adjacency Matrix Representation:</p>
<pre>
<span class="comment">// since 0 is a valid weight, can't use it for "no edge"</span>
<span class="comment">// need a distinguished value to indicate "no edge"</span>
#define NO_EDGE MAXFLOAT  <span class="comment">// imaginary distinguished float value</span>
typedef struct GraphRep {
   int    nV;    <span class="comment">// #vertices</span>
   int    nE;    <span class="comment">// #edges</span>
   Bool **edges; <span class="comment">// matrix of booleans</span>
} GraphRep;
<span class="comment">// check whether two vertices are connected</span>
int neighbours(Graph g, Vertex v, Vertex w)
{
	assert(validV(g,v) &amp;&amp; validV(g,w));
	return (g-&gt;edges[v][w] != NO_EDGE);
}
<span class="comment">// make new graph with nV vertices</span>
Graph newGraph(int nV)
{
   assert(nV &gt;= 0);
   int i, j;
   float **e = malloc(nV * sizeof(float *));
   assert(e != NULL);
   for (i = 0; i &lt; nV; i++) {
      e[i] = malloc(nV * sizeof(float));
      assert(e[i] != NULL);
      for (j = 0; j &lt; nV; j++)
         e[i][j] = NO_EDGE;
   }
   Graph g = malloc(sizeof(GraphRep));
   assert(g != NULL);
   g-&gt;nV = nV;  g-&gt;nE = 0;  g-&gt;edges = e;
   return g;
}
<span class="comment">// free memory allocated to graph</span>
void  dropGraph(Graph g)
{
   assert(g != NULL);
   int i;
   for (i = 0; i &lt; g-&gt;nV; i++)
      free(g-&gt;edges[i]);
   free(g-&gt;edges);
   free(g);
}
<span class="comment">// show "printable" representation of graph</span>
void  showGraph(Graph g)
{
   assert(g != NULL);
   printf("V=%d, E=%d\n", g-&gt;nV, g-&gt;nE);
   int i, j;
   for (i = 0; i &lt; g-&gt;nV; i++) {
      int nshown = 0;
      for (j = i+1; j &lt; g-&gt;nV; j++) {
         float wt = g-&gt;edges[i][j];
         if (wt != NO_EDGE) {
            printf("%d-%0.1f-%d ",i,wt,j);
            nshown++;
         }
      }
      if (nshown &gt; 0) printf("\n");
   }
}
<span class="comment">// add new edge to a graph</span>
void insertE(Graph g, Edge e)
{
   assert(g != NULL);
   Vertex v = e.src, w = e.dest;
   assert(validV(g,v) &amp;&amp; validV(g,w));
   if (G-&gt;edges[v][w] == NO_EDGE) g-&gt;nE++;
   g-&gt;edges[v][w] = e.weight;
}
<span class="comment">// remove an edge from a graph</span>
void removeE(Graph g, Edge e)
{
   assert(g != NULL);
   Vertex v = e.src, w = e.dest;
   assert(validV(g,v) &amp;&amp; validV(g,w));
   if (g-&gt;edges[v][w] == NO_EDGE) return;
   g-&gt;edges[v][w] = NO_EDGE;
   g-&gt;edges[w][v] = NO_EDGE;
   g-&gt;nE--;
}
<span class="comment">// returns #vertices &amp; array of edges</span>
int edges(Graph g, Edge *es, int nE)
{
   assert(g != NULL &amp;&amp; es != NULL);
   assert(nE &gt;= g-&gt;nE);
   int i, j, n = 0;
   for (i = 0; i &lt; g-&gt;nV; i++) {
      for (j = i+1; j &lt; g-&gt;nV; j++) {
         if (g-&gt;edges[i][j] != NO_EDGE) {
            assert(n &lt; nE);
            es[n++] = mkEdge(g,i,j);
         }
      }
   }
   return n;
}
</pre>

<p>Minimum Spanning Tree (Kruskal):</p>
<pre>
typedef Graph MSTree; <span class="comment">// an MST is a specialised Graph</span>
<span class="comment">// assumes existence of list-of-edges ADT</span>
MSTree kruskalFindMST(Graph g)
{
   Graph mst = newGraph(); <span class="comment">//MST initially empty</span>
   EdgeList eList; <span class="comment">//sorted list of edges</span>
   int i;  Edge e;  int eSize = sizeof(Edge);
   edges(eList, g-&gt;nE, g);
   eList = qsort(sorted, g-&gt;nE, eSize, compareE);
   for (i = 0; mst-&gt;nE &lt; g-&gt;nV-1; i++) {
      e = eList[i];
      insertE(mst, e);
      if (hasCycle(mst)) removeE(mst, e);
   }
}
</pre>

<p>Minimum Spanning Tree (Prim):</p>
<pre>
typedef Graph MSTree; <span class="comment">// an MST is a specialised Graph</span>
<span class="comment">// assumes existence of set-of-edges ADT</span>
<span class="comment">// assumes existence of set-of-vertices ADT</span>
MSTree primFindMST(Graph g)
{
   EdgeSet mst = {}; <span class="comment">//MST initially empty</span>
   VertexSet vSet = {0}; <span class="comment">// start vertex</span>
   EdgeSet fringe = {}; <span class="comment">//edges at "fringe"</span>
   Vertex curr, s, t;  Edge e;  float w;
   fringe = edgesAt(0);
   while (card(vSet) &lt; g-&gt;nV) {
      find e in fringe with minimum cost
      fringe = exclude(fringe, e)
      (s,curr,w) = e
      vSet = include(vSet, curr)
      mst = include(mst, e)
      foreach (e in edgesAt(curr)) {
         (s,t,w) = e  <span class="comment">// s == curr</span>
         if (!isElem(t,vSet))
            fringe = include(fringe,e)
      }
   }
}
</pre>

<p>Single-source Shortest Path (Dijkstra):</p>
<pre>
float *dist; <span class="comment">dist[d] = distance of shortest path from s..d</span>
Vertex *pred; <span class="comment">pred[v] = predecessor of v in shortest path</span>
<span class="comment">// assumes existence of set-of-vertices ADT</span>
<span class="comment">// assumes existence of priority queue ADT</span>
<span class="comment">// abstract algorithm only ...</span>
MSTree shortestPath(Graph g, Vertex s)
{
   VertexSet vSet = {}; <span class="comment">// visited vertices</span>
   PQueue todo = newPQueue(); <span class="comment">// edges to be considered</span>
   float *dist = malloc(g-&gt;nV*sizeof(float);
   for (int i = 0; i &lt; g-&gt;nV; i++) dist[i] = MAXFLOAT;
   dist[s] = 0.0;
   Vertex *pred = malloc(g-&gt;nV*sizeof(Vertex));
   for (i = 0; i &lt; g-&gt;nV; i++) pred[i] = -1;
   Vertex v, w, s, t;  Edge e;  float wt;
   PQueueJoin(todo, s, dist[s]);
   while (!PQueueIsEmpty(todo)) {
      v = PQueueLeave(todo);
      if (isElem(vSet,v)) continue;
      vSet = include(vSet, v)
      foreach (e=(v,w,wt) in edgesAt(v)) {
         if (dist[v] + wt &lt; dist[w]) {
            dist[w] = dist[v] + wt;
            pred[w] = v;
            PQueueJoin(todo, w, dist[w]);
         }
      }
   }
}
</pre>

</body>
</html>
